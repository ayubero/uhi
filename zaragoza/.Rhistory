#variogram_model <- vgm(psill = 1, model = "Sph", range = 1000, nugget = 0.1)
fitted_variogram <- fit.variogram(
variogram(temp_diff ~ svf + imd + ndvi, data = points),
model = vgm("Sph")
)
print(fitted_variogram)
plot(variogram(temp_diff ~ svf + imd + ndvi, data = points), fitted_variogram)
# Perform cross-validation to evaluate the model's predictive performance
cv_results <- krige.cv(
formula = temp_diff ~ svf + imd + ndvi, # Specify the response variable and covariates
locations = points, # Spatial data points
model = fitted_variogram, # Variogram model
nfold = 10 # Number of folds for cross-validation
)
print(cv_results)
# Calculate RMSE from cross-validation residuals
residuals <- cv_results$observed - cv_results$var1.pred
rmse <- sqrt(mean(residuals^2))
cat("RMSE:", rmse, "\n")
# --- INTERPOLATION ---
# Paths to the .tif files
svf_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Sky_View_Factor_scaled.tif"
imd_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Imperviousness_Density_normalized_scaled.tif"
ndvi_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_NDVI_scaled.tif"
swir2_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_SWIR2_normalized_scaled.tif"
# Load the .tif files as raster layers
svf_raster <- raster(svf_path)
imd_raster <- raster(imd_path)
ndvi_raster <- raster(ndvi_path)
swir2_raster <- raster(swir2_path)
# Ensure all rasters have the same CRS, extent, and resolution
template <- svf_raster # Use one raster as the template
imd_raster <- resample(imd_raster, template, method = "bilinear")
ndvi_raster <- resample(ndvi_raster, template, method = "bilinear")
swir2_raster <- resample(swir2_raster, template, method = "bilinear")
# Stack the covariate rasters
covariates_stack <- stack(svf_raster, imd_raster, ndvi_raster, swir2_raster)
names(covariates_stack) <- c("svf", "imd", "ndvi", "swir2") # Set layer names
# Convert the raster stack to a SpatialPixelsDataFrame
covariates_spdf <- as(covariates_stack, "SpatialPixelsDataFrame")
# Ensure your spatial points have the same CRS
proj4string(points) <- proj4string(template)
# Perform kriging interpolation
kriging_result <- krige(
formula = temp_diff ~ svf + imd + ndvi,  # Interpolation formula
locations = points,                     # Spatial data points
newdata = covariates_spdf,              # Raster stack as spatial grid
model = fitted_variogram                 # Variogram model
)
# Convert the kriging result back to a raster
raster_output <- raster(kriging_result)
# Save the output as a GeoTIFF file
output_path <- "~/University/uhi/zaragoza/interpolation_SVF+IMD+NDVI.tif"
writeRaster(raster_output, filename = output_path, format = "GTiff", overwrite = TRUE)
# Load libraries
library(gstat)
library(raster)
library(caret)
library(readr)
# Load the CSV file into a dataframe
data <- read_csv("~/University/uhi/zaragoza/data.csv")
# Check the first few rows of the dataset
head(data)
# Check correlation
cor(data$temp_diff, data$svf, use = "complete.obs")
cor(data$temp_diff, data$imd, use = "complete.obs")
cor(data$temp_diff, data$ndvi, use = "complete.obs")
points <- data.frame(
lon = data$lon,
lat = data$lat,
svf = data$svf,
imd = data$imd,
ndvi = data$ndvi,
swir2 = data$swir2,
temp_diff = data$temp_diff
)
# Convert the data frame to a spatial data frame
coordinates(points) <- ~lon + lat
# Ensure the data is in a SpatialPointsDataFrame (this will automatically include the coordinates as spatial information)
proj4string(points) <- CRS("+proj=longlat +datum=WGS84")
# Check the structure of the spatial points data
str(points)
# Define the variogram model
#variogram_model <- vgm(psill = 1, model = "Sph", range = 1000, nugget = 0.1)
fitted_variogram <- fit.variogram(
variogram(temp_diff ~ svf + imd + ndvi, data = points),
model = vgm("Sph")
)
print(fitted_variogram)
plot(variogram(temp_diff ~ svf + imd + ndvi, data = points), fitted_variogram)
# Perform cross-validation to evaluate the model's predictive performance
cv_results <- krige.cv(
formula = temp_diff ~ svf + imd + ndvi, # Specify the response variable and covariates
locations = points, # Spatial data points
model = fitted_variogram, # Variogram model
nfold = 10 # Number of folds for cross-validation
)
print(cv_results)
# Calculate RMSE from cross-validation residuals
residuals <- cv_results$observed - cv_results$var1.pred
rmse <- sqrt(mean(residuals^2))
cat("RMSE:", rmse, "\n")
# --- INTERPOLATION ---
# Paths to the .tif files
svf_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Sky_View_Factor_scaled.tif"
imd_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Imperviousness_Density_normalized_scaled.tif"
ndvi_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_NDVI_scaled.tif"
swir2_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_SWIR2_normalized_scaled.tif"
# Load the .tif files as raster layers
svf_raster <- raster(svf_path)
imd_raster <- raster(imd_path)
ndvi_raster <- raster(ndvi_path)
swir2_raster <- raster(swir2_path)
# Ensure all rasters have the same CRS, extent, and resolution
template <- svf_raster # Use one raster as the template
imd_raster <- resample(imd_raster, template, method = "bilinear")
ndvi_raster <- resample(ndvi_raster, template, method = "bilinear")
swir2_raster <- resample(swir2_raster, template, method = "bilinear")
# Stack the covariate rasters
covariates_stack <- stack(svf_raster, imd_raster, ndvi_raster, swir2_raster)
names(covariates_stack) <- c("svf", "imd", "ndvi", "swir2") # Set layer names
# Convert the raster stack to a SpatialPixelsDataFrame
covariates_spdf <- as(covariates_stack, "SpatialPixelsDataFrame")
# Ensure your spatial points have the same CRS
proj4string(points) <- proj4string(template)
# Perform kriging interpolation
kriging_result <- krige(
formula = temp_diff ~ svf + imd + ndvi,  # Interpolation formula
locations = points,                     # Spatial data points
newdata = covariates_spdf,              # Raster stack as spatial grid
model = fitted_variogram                 # Variogram model
)
# Convert the kriging result back to a raster
raster_output <- raster(kriging_result)
# Save the output as a GeoTIFF file
output_path <- "~/University/uhi/zaragoza/interpolation_SVF+IMD+NDVI.tif"
writeRaster(raster_output, filename = output_path, format = "GTiff", overwrite = TRUE)
# Load libraries
library(gstat)
library(raster)
library(caret)
library(readr)
# Load the CSV file into a dataframe
data <- read_csv("~/University/uhi/zaragoza/data.csv")
# Check the first few rows of the dataset
head(data)
# Check correlation
cor(data$temp_diff, data$svf, use = "complete.obs")
cor(data$temp_diff, data$imd, use = "complete.obs")
cor(data$temp_diff, data$ndvi, use = "complete.obs")
# Prepare spatial data
points <- data.frame(
lon = data$lon,
lat = data$lat,
svf = data$svf,
imd = data$imd,
ndvi = data$ndvi,
swir2 = data$swir2,
temp_diff = data$temp_diff
)
# Convert the data frame to a spatial data frame
coordinates(points) <- ~lon + lat
proj4string(points) <- CRS("+proj=longlat +datum=WGS84")
# Compute cross-variograms
vario <- variogram(temp_diff + svf + imd + ndvi ~ 1, data = points)
fit_vario <- fit.lmc(vario, model = vgm(1, "Sph", 1000, 0.1))
print(fit_vario)
plot(vario, model = fit_vario)
# Compute cross-variograms
vario <- variogram(temp_diff + svf + imd + ndvi ~ 1, data = points)
cov_matrix <- variogramLine(vgm(1, "Sph", 1000, 0.1), dist = seq(0, max(vario$dist), length.out = 10))$gamma
# Compute cross-variograms
vario <- variogram(temp_diff + svf + imd + ndvi ~ 1, data = points)
# Define the distance vector for the variogram
dist_vector <- seq(0, max(vario$dist), length.out = 10)
# Fit a linear model of coregionalization (LMC)
cov_matrix <- variogramLine(vgm(1, "Sph", 1000, 0.1), dist = dist_vector)$gamma
# Compute cross-variograms
vario <- variogram(temp_diff + svf + imd + ndvi ~ 1, data = points)
# Specify the maximum distance for the variogram model
max_dist <- max(vario$dist)
# Fit a linear model of coregionalization (LMC)
cov_matrix <- variogramLine(vgm(1, "Sph", 1000, 0.1), maxdist = max_dist)$gamma
fit_vario <- fit.lmc(vario, model = vgm(1, "Sph", 1000, 0.1), g = cov_matrix)
# Compute cross-variograms
vario <- variogram(temp_diff + svf + imd + ndvi ~ 1, data = points)
# Fit a variogram model
vgm_model <- vgm(1, "Sph", 1000, 0.1)  # Spherical model with sill, range, and nugget
# Fit the model to the variogram data
fit_vario <- fit.variogram(vario, model = vgm_model)
print(fit_vario)
plot(vario, model = fit_vario)
# Fit the variogram model with adjusted parameters and increased iterations
vgm_model <- vgm(psill = 1, model = "Sph", range = 1000, nugget = 0.1)  # Initial model parameters
# Try fitting the variogram again with a larger number of iterations
fit_vario <- tryCatch(
{
fit.variogram(vario, model = vgm_model, maxiter = 500)  # Increase max iterations
},
error = function(e) {
message("Error in fitting variogram: ", e$message)
return(NULL)
}
)
# Try fitting the variogram again with a larger number of iterations
fit_vario <- tryCatch(
{
fit.variogram(vario, model = vgm_model)  # Increase max iterations
},
error = function(e) {
message("Error in fitting variogram: ", e$message)
return(NULL)
}
)
# Perform cokriging interpolation
cokriging_result <- krige(
formula = temp_diff ~ 1,
locations = points,
newdata = covariates_spdf,
model = fit_vario
)
# Convert the cokriging result back to a raster
raster_output <- raster(cokriging_result)
# Fit the model to the variogram data
fit_vario <- fit.variogram(vario, model = vgm_model)
print(fit_vario)
plot(vario, model = fit_vario)
# Perform cokriging interpolation
cokriging_result <- krige(
formula = temp_diff ~ 1,
locations = points,
newdata = covariates_spdf,
model = fit_vario
)
# Convert the cokriging result back to a raster
raster_output <- raster(cokriging_result)
# Save the output as a GeoTIFF file
output_path <- "~/University/uhi/zaragoza/interpolation_COKRIGING.tif"
writeRaster(raster_output, filename = output_path, format = "GTiff", overwrite = TRUE)
# Load libraries
library(gstat)
library(raster)
library(caret)
library(readr)
library(gridExtra)
library(sp)
# Load the CSV file into a dataframe
data <- read_csv("~/University/uhi/zaragoza/data.csv")
# Check correlation between temp_diff and covariates
cor(data$temp_diff, data$svf, use = "complete.obs")
cor(data$temp_diff, data$imd, use = "complete.obs")
cor(data$temp_diff, data$ndvi, use = "complete.obs")
# Load NDVI raster
ndvi_raster <- raster("~/University/uhi/data/rasters/Zaragoza_ETRS89_NDVI_scaled.tif")
plot(ndvi_raster, main = "NDVI Raster")  # Verify raster is loaded correctly
# Prepare spatial data frame
points <- data.frame(
lon = data$lon,
lat = data$lat,
svf = data$svf,
imd = data$imd,
ndvi = data$ndvi,
temp_diff = data$temp_diff
)
# Convert the data frame to a spatial data frame
coordinates(points) <- ~lon + lat
proj4string(points) <- CRS("+proj=longlat +datum=WGS84")
# Extract NDVI values from raster at point locations
points$ndvi_raster <- extract(ndvi_raster, points)
# Check correlation with raster-based NDVI
cor(points$temp_diff, points$ndvi_raster, use = "complete.obs")
# Direct variogram of temp_diff
variogram_temp <- variogram(temp_diff ~ 1, data = points, cloud=F)
model_temp <- vgm(1.5, "Exp", 1, 0.5)  # Initial parameter estimation
model_fit_temp <- fit.variogram(variogram_temp, model_temp)
p1 <- plot(variogram_temp, pl=F, model=model_fit_temp, main= "Temp Diff Variogram")
# Direct variogram of raster-extracted NDVI
variogram_ndvi <- variogram(ndvi_raster ~ 1, data = points, cloud=F)
model_ndvi <- vgm(1.5, "Exp", 1, 0.5)
model_fit_ndvi <- fit.variogram(variogram_ndvi, model_ndvi)
p2 <- plot(variogram_ndvi, pl=F, model=model_fit_ndvi, main="NDVI Variogram")
# Display variograms side by side
grid.arrange(p1, p2, ncol = 2)
# Define gstat object for cokriging
g <- gstat(NULL, id = "temp", form = temp_diff ~ 1, data=points)
g <- gstat(g, id = "ndvi_raster", form = ndvi_raster ~ 1, data=points)
# Compute cross-variogram
cross_variogram <- variogram(g)
plot(cross_variogram, pl=F)
# Fit variogram models
g <- gstat(g, id = "temp_diff", model = model_fit_temp, fill.all=T)
g <- fit.lmc(cross_variogram, g)
# Print fitted model details
print(g)
# Plot fitted variogram
plot(variogram(g), model=g$model)
# Define prediction grid (bounding box of data)
bbox <- extent(min(data$lon), max(data$lon), min(data$lat), max(data$lat))
grid <- raster(bbox, ncol = 100, nrow = 100)  # Adjust ncol and nrow for resolution
projection(grid) <- CRS("+proj=longlat +datum=WGS84")
# Predict using co-kriging
CK <- predict(g, grid)
# Convert prediction to raster and plot
CK_raster <- raster(CK)
plot(CK_raster, main = "Cokriged Prediction (Temp Diff)")
# Create a regular grid covering the study area
bbox <- extent(min(data$lon), max(data$lon), min(data$lat), max(data$lat))
grid_res <- 0.001  # Adjust resolution as needed
grid <- expand.grid(
lon = seq(bbox@xmin, bbox@xmax, by = grid_res),
lat = seq(bbox@ymin, bbox@ymax, by = grid_res)
)
# Convert to SpatialPixelsDataFrame
coordinates(grid) <- ~lon + lat
gridded(grid) <- TRUE
proj4string(grid) <- CRS("+proj=longlat +datum=WGS84")  # Match projection
# Predict using co-kriging
CK <- predict(g, grid)
# Convert prediction to raster and plot
CK_raster <- raster(CK)
plot(CK_raster, main = "Cokriged Prediction (Temp Diff)")
# Save raster output
writeRaster(CK_raster, filename = "~/University/uhi/kriged_temp_diff.tif", format = "GTiff", overwrite=TRUE)
library(gstat)
library(raster)
library(sp)
library(rgdal)
library(gridExtra)
library(readr)
# Load CSV data (points)
data <- read_csv("~/University/uhi/zaragoza/data.csv")
# Read raster files
ndvi_raster <- raster("~/University/uhi/data/rasters/Zaragoza_ETRS89_NDVI_scaled.tif")
svf_raster <- raster("~/University/uhi/data/rasters/Zaragoza_ETRS89_Sky_View_Factor_scaled.tif")
imd_raster <- raster("~/University/uhi/data/rasters/Zaragoza_ETRS89_Imperviousness_Density_normalized_scaled.tif")
# Extract raster values at data points
data$ndvi <- extract(ndvi_raster, cbind(data$lon, data$lat))
data$svf <- extract(svf_raster, cbind(data$lon, data$lat))
data$imd <- extract(imd_raster, cbind(data$lon, data$lat))
# Remove NA values (if any points are outside raster coverage)
data <- na.omit(data)
# Convert dataframe to SpatialPointsDataFrame
coordinates(data) <- ~lon + lat
proj4string(data) <- CRS("+proj=longlat +datum=WGS84")
# Load libraries
library(gstat)
library(raster)
library(caret)
library(readr)
library(gridExtra)
library(sp)
# Load the CSV file into a dataframe
data <- read_csv("~/University/uhi/zaragoza/data.csv")
# Check correlation between temp_diff and covariates
cor(data$temp_diff, data$svf, use = "complete.obs")
cor(data$temp_diff, data$imd, use = "complete.obs")
cor(data$temp_diff, data$ndvi, use = "complete.obs")
# Load NDVI raster
ndvi_raster <- raster("~/University/uhi/data/rasters/Zaragoza_ETRS89_NDVI_scaled.tif")
plot(ndvi_raster, main = "NDVI Raster")  # Verify raster is loaded correctly
# Prepare spatial data frame
points <- data.frame(
lon = data$lon,
lat = data$lat,
svf = data$svf,
imd = data$imd,
ndvi = data$ndvi,
temp_diff = data$temp_diff
)
# Convert the data frame to a spatial data frame
coordinates(points) <- ~lon + lat
proj4string(points) <- CRS("+proj=longlat +datum=WGS84")
# Extract NDVI values from raster at point locations
points$ndvi_raster <- extract(ndvi_raster, points)
# Check correlation with raster-based NDVI
cor(points$temp_diff, points$ndvi_raster, use = "complete.obs")
# Direct variogram of temp_diff
variogram_temp <- variogram(temp_diff ~ 1, data = points, cloud=F)
model_temp <- vgm(1.5, "Exp", 1, 0.5)  # Initial parameter estimation
model_fit_temp <- fit.variogram(variogram_temp, model_temp)
p1 <- plot(variogram_temp, pl=F, model=model_fit_temp, main= "Temp Diff Variogram")
# Direct variogram of raster-extracted NDVI
variogram_ndvi <- variogram(ndvi_raster ~ 1, data = points, cloud=F)
model_ndvi <- vgm(1.5, "Exp", 1, 0.5)
model_fit_ndvi <- fit.variogram(variogram_ndvi, model_ndvi)
p2 <- plot(variogram_ndvi, pl=F, model=model_fit_ndvi, main="NDVI Variogram")
# Display variograms side by side
grid.arrange(p1, p2, ncol = 2)
# Define gstat object for cokriging
g <- gstat(NULL, id = "temp", form = temp_diff ~ 1, data=points)
g <- gstat(g, id = "ndvi_raster", form = ndvi_raster ~ 1, data=points)
# Compute cross-variogram
cross_variogram <- variogram(g)
plot(cross_variogram, pl=F)
# Fit variogram models
g <- gstat(g, id = "temp_diff", model = model_fit_temp, fill.all=T)
g <- fit.lmc(cross_variogram, g)
# Print fitted model details
print(g)
# Plot fitted variogram
plot(variogram(g), model=g$model)
# Create a regular grid covering the study area
bbox <- extent(min(data$lon), max(data$lon), min(data$lat), max(data$lat))
grid_res <- 0.001  # Adjust resolution as needed
grid <- expand.grid(
lon = seq(bbox@xmin, bbox@xmax, by = grid_res),
lat = seq(bbox@ymin, bbox@ymax, by = grid_res)
)
# Convert to SpatialPixelsDataFrame
coordinates(grid) <- ~lon + lat
gridded(grid) <- TRUE
proj4string(grid) <- CRS("+proj=longlat +datum=WGS84")  # Match projection
# Predict using co-kriging
CK <- predict(g, grid)
# Convert prediction to raster and plot
CK_raster <- raster(CK)
plot(CK_raster, main = "Cokriged Prediction (Temp Diff)")
# Save raster output
writeRaster(CK_raster, filename = "~/University/uhi/kriged_temp_diff.tif", format = "GTiff", overwrite=TRUE)
# Load libraries
library(gstat)
library(raster)
library(caret)
library(readr)
library(gridExtra)
library(sp)
# Load the CSV file into a dataframe
data <- read_csv("~/University/uhi/zaragoza/data.csv")
# Check correlation between temp_diff and covariates
cor(data$temp_diff, data$svf, use = "complete.obs")
cor(data$temp_diff, data$imd, use = "complete.obs")
cor(data$temp_diff, data$ndvi, use = "complete.obs")
# Load raster datasets
ndvi_raster <- raster("~/University/uhi/data/rasters/Zaragoza_ETRS89_NDVI_scaled.tif")
svf_raster <- raster("~/University/uhi/data/rasters/Zaragoza_ETRS89_Sky_View_Factor_scaled.tif")
imd_raster <- raster("~/University/uhi/data/rasters/Zaragoza_ETRS89_Imperviousness_Density_normalized_scaled.tif")
# Verify rasters are loaded correctly
plot(ndvi_raster, main = "NDVI Raster")
plot(svf_raster, main = "SVF Raster")
plot(imd_raster, main = "IMD Raster")
# Prepare spatial data frame
points <- data.frame(
lon = data$lon,
lat = data$lat,
svf = data$svf,
imd = data$imd,
ndvi = data$ndvi,
temp_diff = data$temp_diff
)
# Convert the data frame to a spatial data frame
coordinates(points) <- ~lon + lat
proj4string(points) <- CRS("+proj=longlat +datum=WGS84")
# Extract raster values at point locations
points$ndvi_raster <- extract(ndvi_raster, points)
points$svf_raster <- extract(svf_raster, points)
points$imd_raster <- extract(imd_raster, points)
# Check correlations
cor(points$temp_diff, points$ndvi_raster, use = "complete.obs")
cor(points$temp_diff, points$svf_raster, use = "complete.obs")
cor(points$temp_diff, points$imd_raster, use = "complete.obs")
# Define variograms for each variable
variogram_temp <- variogram(temp_diff ~ 1, data = points, cloud=F)
model_temp <- vgm(1.5, "Exp", 1, 0.5)
model_fit_temp <- fit.variogram(variogram_temp, model_temp)
variogram_ndvi <- variogram(ndvi_raster ~ 1, data = points, cloud=F)
model_ndvi <- vgm(1.5, "Exp", 1, 0.5)
model_fit_ndvi <- fit.variogram(variogram_ndvi, model_ndvi)
variogram_svf <- variogram(svf_raster ~ 1, data = points, cloud=F)
model_svf <- vgm(1.5, "Exp", 1, 0.5)
model_fit_svf <- fit.variogram(variogram_svf, model_svf)
variogram_imd <- variogram(imd_raster ~ 1, data = points, cloud=F)
model_imd <- vgm(1.5, "Exp", 1, 0.5)
model_fit_imd <- fit.variogram(variogram_imd, model_imd)
# Display variograms
grid.arrange(plot(variogram_temp, pl=F, model=model_fit_temp, main= "Temp Diff Variogram"),
plot(variogram_ndvi, pl=F, model=model_fit_ndvi, main="NDVI Variogram"),
plot(variogram_svf, pl=F, model=model_fit_svf, main="SVF Variogram"),
plot(variogram_imd, pl=F, model=model_fit_imd, main="IMD Variogram"),
ncol=2)
# Define gstat object for cokriging
g <- gstat(NULL, id = "temp", form = temp_diff ~ 1, data=points)
g <- gstat(g, id = "ndvi_raster", form = ndvi_raster ~ 1, data=points)
g <- gstat(g, id = "svf_raster", form = svf_raster ~ 1, data=points)
g <- gstat(g, id = "imd_raster", form = imd_raster ~ 1, data=points)
# Compute cross-variogram
cross_variogram <- variogram(g)
plot(cross_variogram, pl=F)
# Fit variogram models
g <- gstat(g, id = "temp_diff", model = model_fit_temp, fill.all=T)
g <- fit.lmc(cross_variogram, g)
# Print fitted model details
print(g)
# Plot fitted variogram
plot(variogram(g), model=g$model)
# Create a regular grid covering the study area
bbox <- extent(min(data$lon), max(data$lon), min(data$lat), max(data$lat))
grid_res <- 0.001  # Adjust resolution as needed
grid <- expand.grid(
lon = seq(bbox@xmin, bbox@xmax, by = grid_res),
lat = seq(bbox@ymin, bbox@ymax, by = grid_res)
)
# Convert to SpatialPixelsDataFrame
coordinates(grid) <- ~lon + lat
gridded(grid) <- TRUE
proj4string(grid) <- CRS("+proj=longlat +datum=WGS84")
# Predict using co-kriging
CK <- predict(g, grid)
# Convert prediction to raster and plot
CK_raster <- raster(CK)
plot(CK_raster, main = "Cokriged Prediction (Temp Diff)")
# Save raster output
writeRaster(CK_raster, filename = "~/University/uhi/kriged_temp_diff.tif", format = "GTiff", overwrite=TRUE)
