models <- c("Sph", "Exp", "Gau", "Mat")
fitted_models <- lapply(models, function(model) {
fit.variogram(variogram(temp_diff ~ svf + imd + ndvi, data = points), vgm(model))
})
names(fitted_models) <- models
fitted_models
cv_results <- krige.cv(temp_diff ~ svf + imd + ndvi, points, model = fitted_models[["Mat"]])
residuals <- cv_results$observed - cv_results$var1.pred
rmse <- sqrt(mean(residuals^2))
cat("RMSE:", rmse, "\n")
}
# Perform cross-validation to evaluate the model's predictive performance
cv_results <- krige.cv(
formula = temp_diff ~ svf + imd + ndvi, # Specify the response variable and covariates
locations = points, # Spatial data points
model = fitted_variogram, # Variogram model
nfold = 10 # Number of folds for cross-validation
)
print(cv_results)
# Calculate RMSE from cross-validation residuals
residuals <- cv_results$observed - cv_results$var1.pred
rmse <- sqrt(mean(residuals^2))
cat("RMSE:", rmse, "\n")
# --- INTERPOLATION ---
# Paths to the .tif files
svf_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Sky_View_Factor_scaled.tif"
imd_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Imperviousness_Density_normalized_scaled.tif"
ndvi_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_NDVI_scaled.tif"
swir2_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_SWIR2_normalized_scaled.tif"
# Load the .tif files as raster layers
svf_raster <- raster(svf_path)
imd_raster <- raster(imd_path)
ndvi_raster <- raster(ndvi_path)
swir2_raster <- raster(swir2_path)
# Ensure all rasters have the same CRS, extent, and resolution
template <- svf_raster # Use one raster as the template
imd_raster <- resample(imd_raster, template, method = "bilinear")
ndvi_raster <- resample(ndvi_raster, template, method = "bilinear")
swir2_raster <- resample(swir2_raster, template, method = "bilinear")
# Stack the covariate rasters
covariates_stack <- stack(svf_raster, imd_raster, ndvi_raster, swir2_raster)
names(covariates_stack) <- c("svf", "imd", "ndvi", "swir2") # Set layer names
# Convert the raster stack to a SpatialPixelsDataFrame
covariates_spdf <- as(covariates_stack, "SpatialPixelsDataFrame")
# Ensure your spatial points have the same CRS
proj4string(points) <- proj4string(template)
# Perform kriging interpolation
kriging_result <- krige(
formula = temp_diff ~ svf + imd + ndvi,  # Interpolation formula
locations = points,                     # Spatial data points
newdata = covariates_spdf,              # Raster stack as spatial grid
model = fitted_variogram                 # Variogram model
)
# Convert the kriging result back to a raster
raster_output <- raster(kriging_result)
# Save the output as a GeoTIFF file
output_path <- "~/University/uhi/zaragoza/interpolation_SVF+IMD+NDVI.tif"
writeRaster(raster_output, filename = output_path, format = "GTiff", overwrite = TRUE)
warnings()
# Perform kriging interpolation
kriging_result <- krige(
formula = temp_diff ~ svf + imd + ndvi,  # Interpolation formula
locations = points,                     # Spatial data points
newdata = covariates_spdf,              # Raster stack as spatial grid
model = fitted_variogram                 # Variogram model
)
warnings()
# Step 1: Define a grid over the study area
grid <- spsample(points, type = "regular", n = 10000) # Adjust `n` for grid density
gridded(grid) <- TRUE
# Step 2: Perform kriging on the grid using the variogram model
kriging_result <- krige(
formula = temp_diff ~ svf + imd + ndvi, # Same formula as `krige.cv`
locations = points, # Spatial points
newdata = grid, # Prediction grid
model = fitted_variogram # Variogram model
)
# Step 3: Convert kriging predictions to a raster
kriging_raster <- raster(kriging_result, layer = "var1.pred") # Extract predicted values
# Step 4: Export the raster
writeRaster(kriging_raster, filename = "kriging_result.tif", format = "GTiff", overwrite = TRUE)
# --- INTERPOLATION ---
# Paths to the .tif files
svf_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Sky_View_Factor_scaled.tif"
imd_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Imperviousness_Density_normalized_scaled.tif"
ndvi_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_NDVI_scaled.tif"
swir2_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_SWIR2_normalized_scaled.tif"
# Load the .tif files as raster layers
svf_raster <- raster(svf_path)
imd_raster <- raster(imd_path)
ndvi_raster <- raster(ndvi_path)
swir2_raster <- raster(swir2_path)
# Ensure all rasters have the same CRS, extent, and resolution
template <- svf_raster # Use one raster as the template
imd_raster <- resample(imd_raster, template, method = "bilinear")
ndvi_raster <- resample(ndvi_raster, template, method = "bilinear")
swir2_raster <- resample(swir2_raster, template, method = "bilinear")
# Stack the covariate rasters
covariates_stack <- stack(svf_raster, imd_raster, ndvi_raster, swir2_raster)
names(covariates_stack) <- c("svf", "imd", "ndvi", "swir2") # Set layer names
# Convert the raster stack to a SpatialPixelsDataFrame
covariates_spdf <- as(covariates_stack, "SpatialPixelsDataFrame")
# Ensure your spatial points have the same CRS
proj4string(points) <- proj4string(template)
# Load libraries
library(gstat)
library(raster)
library(caret)
library(readr)
# Load the CSV file into a dataframe
data <- read_csv("~/University/uhi/zaragoza/data.csv")
# Check the first few rows of the dataset
head(data)
# Check correlation
cor(data$temp_diff, data$svf, use = "complete.obs")
cor(data$temp_diff, data$imd, use = "complete.obs")
cor(data$temp_diff, data$ndvi, use = "complete.obs")
points <- data.frame(
lon = data$lon,
lat = data$lat,
svf = data$svf,
imd = data$imd,
ndvi = data$ndvi,
swir2 = data$swir2,
temp_diff = data$temp_diff
)
# Convert the data frame to a spatial data frame
coordinates(points) <- ~lon + lat
# Ensure the data is in a SpatialPointsDataFrame (this will automatically include the coordinates as spatial information)
proj4string(points) <- CRS("+proj=longlat +datum=WGS84")
# Check the structure of the spatial points data
str(points)
# Define the variogram model
#variogram_model <- vgm(psill = 1, model = "Sph", range = 1000, nugget = 0.1)
fitted_variogram <- fit.variogram(
variogram(temp_diff ~ svf + imd + ndvi, data = points),
model = vgm("Exp")
)
print(fitted_variogram)
plot(variogram(temp_diff ~ svf + imd + ndvi, data = points), fitted_variogram)
if (FALSE) {
# Candidate variogram models
models <- c("Sph", "Exp", "Gau", "Mat")
fitted_models <- lapply(models, function(model) {
fit.variogram(variogram(temp_diff ~ svf + imd + ndvi, data = points), vgm(model))
})
names(fitted_models) <- models
fitted_models
cv_results <- krige.cv(temp_diff ~ svf + imd + ndvi, points, model = fitted_models[["Mat"]])
residuals <- cv_results$observed - cv_results$var1.pred
rmse <- sqrt(mean(residuals^2))
cat("RMSE:", rmse, "\n")
}
# Perform cross-validation to evaluate the model's predictive performance
cv_results <- krige.cv(
formula = temp_diff ~ svf + imd + ndvi, # Specify the response variable and covariates
locations = points, # Spatial data points
model = fitted_variogram, # Variogram model
nfold = 10 # Number of folds for cross-validation
)
print(cv_results)
# Calculate RMSE from cross-validation residuals
residuals <- cv_results$observed - cv_results$var1.pred
rmse <- sqrt(mean(residuals^2))
cat("RMSE:", rmse, "\n")
# --- INTERPOLATION ---
# Paths to the .tif files
svf_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Sky_View_Factor_scaled.tif"
imd_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Imperviousness_Density_normalized_scaled.tif"
ndvi_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_NDVI_scaled.tif"
swir2_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_SWIR2_normalized_scaled.tif"
# Load the .tif files as raster layers
svf_raster <- raster(svf_path)
imd_raster <- raster(imd_path)
ndvi_raster <- raster(ndvi_path)
swir2_raster <- raster(swir2_path)
# Ensure all rasters have the same CRS, extent, and resolution
template <- svf_raster # Use one raster as the template
imd_raster <- resample(imd_raster, template, method = "bilinear")
ndvi_raster <- resample(ndvi_raster, template, method = "bilinear")
swir2_raster <- resample(swir2_raster, template, method = "bilinear")
# Stack the covariate rasters
covariates_stack <- stack(svf_raster, imd_raster, ndvi_raster, swir2_raster)
names(covariates_stack) <- c("svf", "imd", "ndvi", "swir2") # Set layer names
# Convert the raster stack to a SpatialPixelsDataFrame
covariates_spdf <- as(covariates_stack, "SpatialPixelsDataFrame")
# Ensure your spatial points have the same CRS
proj4string(points) <- proj4string(template)
# Perform kriging interpolation
kriging_result <- krige(
formula = temp_diff ~ svf + imd + ndvi,  # Interpolation formula
locations = points,                     # Spatial data points
newdata = covariates_spdf,              # Raster stack as spatial grid
model = fitted_variogram                 # Variogram model
)
# Convert the kriging result back to a raster
raster_output <- raster(kriging_result)
# Save the output as a GeoTIFF file
output_path <- "~/University/uhi/zaragoza/interpolation_SVF+IMD+NDVI.tif"
writeRaster(raster_output, filename = output_path, format = "GTiff", overwrite = TRUE)
# Define the variogram model
#variogram_model <- vgm(psill = 1, model = "Sph", range = 1000, nugget = 0.1)
fitted_variogram <- fit.variogram(
variogram(temp_diff ~ svf + imd + ndvi, data = points),
model = vgm("Exp")
)
print(fitted_variogram)
plot(variogram(temp_diff ~ svf + imd + ndvi, data = points), fitted_variogram)
# Load libraries
library(gstat)
library(raster)
library(caret)
library(readr)
# Load the CSV file into a dataframe
data <- read_csv("~/University/uhi/zaragoza/data.csv")
# Check the first few rows of the dataset
head(data)
# Check correlation
cor(data$temp_diff, data$svf, use = "complete.obs")
cor(data$temp_diff, data$imd, use = "complete.obs")
cor(data$temp_diff, data$ndvi, use = "complete.obs")
points <- data.frame(
lon = data$lon,
lat = data$lat,
svf = data$svf,
imd = data$imd,
ndvi = data$ndvi,
swir2 = data$swir2,
temp_diff = data$temp_diff
)
# Convert the data frame to a spatial data frame
coordinates(points) <- ~lon + lat
# Ensure the data is in a SpatialPointsDataFrame (this will automatically include the coordinates as spatial information)
proj4string(points) <- CRS("+proj=longlat +datum=WGS84")
# Check the structure of the spatial points data
str(points)
# Define the variogram model
#variogram_model <- vgm(psill = 1, model = "Sph", range = 1000, nugget = 0.1)
fitted_variogram <- fit.variogram(
variogram(temp_diff ~ svf + imd + ndvi, data = points),
model = vgm("Exp")
)
print(fitted_variogram)
plot(variogram(temp_diff ~ svf + imd + ndvi, data = points), fitted_variogram)
# Load libraries
library(gstat)
library(raster)
library(caret)
library(readr)
# Load the CSV file into a dataframe
data <- read_csv("~/University/uhi/zaragoza/data.csv")
# Check the first few rows of the dataset
head(data)
# Check correlation
cor(data$temp_diff, data$svf, use = "complete.obs")
cor(data$temp_diff, data$imd, use = "complete.obs")
cor(data$temp_diff, data$ndvi, use = "complete.obs")
points <- data.frame(
lon = data$lon,
lat = data$lat,
svf = data$svf,
imd = data$imd,
ndvi = data$ndvi,
swir2 = data$swir2,
temp_diff = data$temp_diff
)
# Convert the data frame to a spatial data frame
coordinates(points) <- ~lon + lat
# Ensure the data is in a SpatialPointsDataFrame (this will automatically include the coordinates as spatial information)
proj4string(points) <- CRS("+proj=longlat +datum=WGS84")
# Check the structure of the spatial points data
str(points)
# Define the variogram model
#variogram_model <- vgm(psill = 1, model = "Sph", range = 1000, nugget = 0.1)
fitted_variogram <- fit.variogram(
variogram(temp_diff ~ svf + imd + ndvi, data = points),
model = vgm("Sph")
)
print(fitted_variogram)
plot(variogram(temp_diff ~ svf + imd + ndvi, data = points), fitted_variogram)
# Perform cross-validation to evaluate the model's predictive performance
cv_results <- krige.cv(
formula = temp_diff ~ svf + imd + ndvi, # Specify the response variable and covariates
locations = points, # Spatial data points
model = fitted_variogram, # Variogram model
nfold = 10 # Number of folds for cross-validation
)
print(cv_results)
# Calculate RMSE from cross-validation residuals
residuals <- cv_results$observed - cv_results$var1.pred
rmse <- sqrt(mean(residuals^2))
cat("RMSE:", rmse, "\n")
# --- INTERPOLATION ---
# Paths to the .tif files
svf_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Sky_View_Factor_scaled.tif"
imd_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Imperviousness_Density_normalized_scaled.tif"
ndvi_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_NDVI_scaled.tif"
swir2_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_SWIR2_normalized_scaled.tif"
# Load the .tif files as raster layers
svf_raster <- raster(svf_path)
imd_raster <- raster(imd_path)
ndvi_raster <- raster(ndvi_path)
swir2_raster <- raster(swir2_path)
# Ensure all rasters have the same CRS, extent, and resolution
template <- svf_raster # Use one raster as the template
imd_raster <- resample(imd_raster, template, method = "bilinear")
ndvi_raster <- resample(ndvi_raster, template, method = "bilinear")
swir2_raster <- resample(swir2_raster, template, method = "bilinear")
# Stack the covariate rasters
covariates_stack <- stack(svf_raster, imd_raster, ndvi_raster, swir2_raster)
names(covariates_stack) <- c("svf", "imd", "ndvi", "swir2") # Set layer names
# Convert the raster stack to a SpatialPixelsDataFrame
covariates_spdf <- as(covariates_stack, "SpatialPixelsDataFrame")
# Ensure your spatial points have the same CRS
proj4string(points) <- proj4string(template)
# Perform kriging interpolation
kriging_result <- krige(
formula = temp_diff ~ svf + imd + ndvi,  # Interpolation formula
locations = points,                     # Spatial data points
newdata = covariates_spdf,              # Raster stack as spatial grid
model = fitted_variogram                 # Variogram model
)
# Convert the kriging result back to a raster
raster_output <- raster(kriging_result)
# Save the output as a GeoTIFF file
output_path <- "~/University/uhi/zaragoza/interpolation_SVF+IMD+NDVI.tif"
writeRaster(raster_output, filename = output_path, format = "GTiff", overwrite = TRUE)
# Load libraries
library(gstat)
library(raster)
library(caret)
library(readr)
# Load the CSV file into a dataframe
data <- read_csv("~/University/uhi/zaragoza/data.csv")
# Check the first few rows of the dataset
head(data)
# Check correlation
cor(data$temp_diff, data$svf, use = "complete.obs")
cor(data$temp_diff, data$imd, use = "complete.obs")
cor(data$temp_diff, data$ndvi, use = "complete.obs")
points <- data.frame(
lon = data$lon,
lat = data$lat,
svf = data$svf,
imd = data$imd,
ndvi = data$ndvi,
swir2 = data$swir2,
temp_diff = data$temp_diff
)
# Convert the data frame to a spatial data frame
coordinates(points) <- ~lon + lat
# Ensure the data is in a SpatialPointsDataFrame (this will automatically include the coordinates as spatial information)
proj4string(points) <- CRS("+proj=longlat +datum=WGS84")
# Check the structure of the spatial points data
str(points)
# Define the variogram model
#variogram_model <- vgm(psill = 1, model = "Sph", range = 1000, nugget = 0.1)
fitted_variogram <- fit.variogram(
variogram(temp_diff ~ svf + imd + ndvi, data = points),
model = vgm("Sph")
)
print(fitted_variogram)
plot(variogram(temp_diff ~ svf + imd + ndvi, data = points), fitted_variogram)
# Perform cross-validation to evaluate the model's predictive performance
cv_results <- krige.cv(
formula = temp_diff ~ svf + imd + ndvi, # Specify the response variable and covariates
locations = points, # Spatial data points
model = fitted_variogram, # Variogram model
nfold = 10 # Number of folds for cross-validation
)
print(cv_results)
# Calculate RMSE from cross-validation residuals
residuals <- cv_results$observed - cv_results$var1.pred
rmse <- sqrt(mean(residuals^2))
cat("RMSE:", rmse, "\n")
# --- INTERPOLATION ---
# Paths to the .tif files
svf_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Sky_View_Factor_scaled.tif"
imd_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_Imperviousness_Density_normalized_scaled.tif"
ndvi_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_NDVI_scaled.tif"
swir2_path <- "~/University/uhi/data/rasters/Zaragoza_ETRS89_SWIR2_normalized_scaled.tif"
# Load the .tif files as raster layers
svf_raster <- raster(svf_path)
imd_raster <- raster(imd_path)
ndvi_raster <- raster(ndvi_path)
swir2_raster <- raster(swir2_path)
# Ensure all rasters have the same CRS, extent, and resolution
template <- svf_raster # Use one raster as the template
imd_raster <- resample(imd_raster, template, method = "bilinear")
ndvi_raster <- resample(ndvi_raster, template, method = "bilinear")
swir2_raster <- resample(swir2_raster, template, method = "bilinear")
# Stack the covariate rasters
covariates_stack <- stack(svf_raster, imd_raster, ndvi_raster, swir2_raster)
names(covariates_stack) <- c("svf", "imd", "ndvi", "swir2") # Set layer names
# Convert the raster stack to a SpatialPixelsDataFrame
covariates_spdf <- as(covariates_stack, "SpatialPixelsDataFrame")
# Ensure your spatial points have the same CRS
proj4string(points) <- proj4string(template)
# Perform kriging interpolation
kriging_result <- krige(
formula = temp_diff ~ svf + imd + ndvi,  # Interpolation formula
locations = points,                     # Spatial data points
newdata = covariates_spdf,              # Raster stack as spatial grid
model = fitted_variogram                 # Variogram model
)
# Convert the kriging result back to a raster
raster_output <- raster(kriging_result)
# Save the output as a GeoTIFF file
output_path <- "~/University/uhi/zaragoza/interpolation_SVF+IMD+NDVI.tif"
writeRaster(raster_output, filename = output_path, format = "GTiff", overwrite = TRUE)
# Load libraries
library(gstat)
library(raster)
library(caret)
library(readr)
# Load the CSV file into a dataframe
data <- read_csv("~/University/uhi/zaragoza/data.csv")
# Check the first few rows of the dataset
head(data)
# Check correlation
cor(data$temp_diff, data$svf, use = "complete.obs")
cor(data$temp_diff, data$imd, use = "complete.obs")
cor(data$temp_diff, data$ndvi, use = "complete.obs")
# Prepare spatial data
points <- data.frame(
lon = data$lon,
lat = data$lat,
svf = data$svf,
imd = data$imd,
ndvi = data$ndvi,
swir2 = data$swir2,
temp_diff = data$temp_diff
)
# Convert the data frame to a spatial data frame
coordinates(points) <- ~lon + lat
proj4string(points) <- CRS("+proj=longlat +datum=WGS84")
# Compute cross-variograms
vario <- variogram(temp_diff + svf + imd + ndvi ~ 1, data = points)
fit_vario <- fit.lmc(vario, model = vgm(1, "Sph", 1000, 0.1))
print(fit_vario)
plot(vario, model = fit_vario)
# Compute cross-variograms
vario <- variogram(temp_diff + svf + imd + ndvi ~ 1, data = points)
cov_matrix <- variogramLine(vgm(1, "Sph", 1000, 0.1), dist = seq(0, max(vario$dist), length.out = 10))$gamma
# Compute cross-variograms
vario <- variogram(temp_diff + svf + imd + ndvi ~ 1, data = points)
# Define the distance vector for the variogram
dist_vector <- seq(0, max(vario$dist), length.out = 10)
# Fit a linear model of coregionalization (LMC)
cov_matrix <- variogramLine(vgm(1, "Sph", 1000, 0.1), dist = dist_vector)$gamma
# Compute cross-variograms
vario <- variogram(temp_diff + svf + imd + ndvi ~ 1, data = points)
# Specify the maximum distance for the variogram model
max_dist <- max(vario$dist)
# Fit a linear model of coregionalization (LMC)
cov_matrix <- variogramLine(vgm(1, "Sph", 1000, 0.1), maxdist = max_dist)$gamma
fit_vario <- fit.lmc(vario, model = vgm(1, "Sph", 1000, 0.1), g = cov_matrix)
# Compute cross-variograms
vario <- variogram(temp_diff + svf + imd + ndvi ~ 1, data = points)
# Fit a variogram model
vgm_model <- vgm(1, "Sph", 1000, 0.1)  # Spherical model with sill, range, and nugget
# Fit the model to the variogram data
fit_vario <- fit.variogram(vario, model = vgm_model)
print(fit_vario)
plot(vario, model = fit_vario)
# Fit the variogram model with adjusted parameters and increased iterations
vgm_model <- vgm(psill = 1, model = "Sph", range = 1000, nugget = 0.1)  # Initial model parameters
# Try fitting the variogram again with a larger number of iterations
fit_vario <- tryCatch(
{
fit.variogram(vario, model = vgm_model, maxiter = 500)  # Increase max iterations
},
error = function(e) {
message("Error in fitting variogram: ", e$message)
return(NULL)
}
)
# Try fitting the variogram again with a larger number of iterations
fit_vario <- tryCatch(
{
fit.variogram(vario, model = vgm_model)  # Increase max iterations
},
error = function(e) {
message("Error in fitting variogram: ", e$message)
return(NULL)
}
)
# Perform cokriging interpolation
cokriging_result <- krige(
formula = temp_diff ~ 1,
locations = points,
newdata = covariates_spdf,
model = fit_vario
)
# Convert the cokriging result back to a raster
raster_output <- raster(cokriging_result)
# Fit the model to the variogram data
fit_vario <- fit.variogram(vario, model = vgm_model)
print(fit_vario)
plot(vario, model = fit_vario)
# Perform cokriging interpolation
cokriging_result <- krige(
formula = temp_diff ~ 1,
locations = points,
newdata = covariates_spdf,
model = fit_vario
)
# Convert the cokriging result back to a raster
raster_output <- raster(cokriging_result)
# Save the output as a GeoTIFF file
output_path <- "~/University/uhi/zaragoza/interpolation_COKRIGING.tif"
writeRaster(raster_output, filename = output_path, format = "GTiff", overwrite = TRUE)
